---
layout: post
title: kscript as substitute for awk
description: "kscript is an alternative to tabular data processing in the shell"
categories: [kotlin]
comments: true
---


Among other new [features](https://github.com/holgerbrandl/kscript/blob/master/NEWS.md#v13) [`kscript`](https://github.com/holgerbrandl/kscript) does accept scriptlets as arguments since recently. This makes it possible to use it in an awk-like fashion. For sure its scope of kscript is more broad, but still it's interesting both to compare tools with respect to tabular data processing side by side.


So let's get started. A common usecase of `awk` selecting columns:

```{r, engine='bash'}
# cp ~projects/kotlin/kscript-support-api/src/test/resources/flights.tsv . 
# head  -n 5 flights.tsv > some_flights.tsv 

awk -v OFS='\t' '{print $10, $1, $12}' some_flights.tsv

kscript 'lines.split().select(10,1,12).print()' some_flights.tsv 
```

The `kscript` solution is using Kotlin to implement the same functionality and is just slightly more verbose.

## How does it work?

When a one-liner is provided as script argument to `kscript` it will add the following prefix header
```
kscript '//DEPS de.mpicbg.scicomp:kscript:1.2
import kscript.text.*
val lines = resolveArgFile(args)
```
The header serves 2 purposes. First it imports the support methods from [`kscript.text`](https://github.com/holgerbrandl/kscript-support-api/tree/master/src/main/kotlin/kscript/text). Second, it resolved the input which is assumed either an argument file or `stdin` into a `Sequence<String>` named `lines`.

The resulting script will [be processed](https://github.com/holgerbrandl/kscript#inlined-usage) like any other by `kscript`.

In the example above several other elements of the [`kscript` support library](https://github.com/holgerbrandl/kscript-support-api):

* [`split()`](https://github.com/holgerbrandl/kscript-support-api/blob/1ecbdeecaa68d57a8b2365a42995d7ce3bee28a0/src/main/kotlin/kscript/text/Tables.kt#L37-L37) - splits the lines of an input stream into [Row](https://github.com/holgerbrandl/kscript-support-api/blob/1ecbdeecaa68d57a8b2365a42995d7ce3bee28a0/src/main/kotlin/kscript/text/Tables.kt#L26)s. The latter are just a [typealias](https://kotlinlang.org/docs/reference/type-aliases.html) for `List<String>`
* [`select()`](https://github.com/holgerbrandl/kscript-support-api/blob/1ecbdeecaa68d57a8b2365a42995d7ce3bee28a0/src/main/kotlin/kscript/text/Tables.kt#L109) - which allows to perform positive and negative selections. Both range and index syntax and combinations of both are supported.
* [`print()`](https://github.com/holgerbrandl/kscript-support-api/blob/1ecbdeecaa68d57a8b2365a42995d7ce3bee28a0/src/main/kotlin/kscript/text/Tables.kt#L64) - Joins rows and prints them to `stdout`


Separators characters can be optionally provided and default (using kotlin [default parameters](https://kotlinlang.org/docs/reference/functions.html#default-arguments)) to tab-delimiters.

## Examples


1. [Add a new column to a file](http://stackoverflow.com/questions/7551991/add-a-new-column-to-the-file):

```{r something-in-Bash, engine='bash', comment='Bash>'}
awk '{print $1, $2, "F11-"$7}' some_flights.tsv

kscript 'lines.split().map { listOf(it[1], it[2], "F11-"+ it[7]) }.print()' some_flights.tsv 
```

2. 



## Performance

To assess differences in runtime we use the initial column sub-setting example to process 300k flights

```{r, engine='bash', comment='Bash>'}
wc -l flights.tsv
time awk '{print $10, $1, $12}' flights.tsv > /dev/null

time kscript 'lines.split().select(10,1,12).print()' flights.tsv > /dev/null
```
Both solutions do not differ signifcantly in runtime. However, this actually means that  `kscript` is processing the data faster, because we loose around 350ms because of the JVM startup. To illustrate that point we redo the benchmark with 20x of the data.

```
# moreFlights="flights.tsv flights.tsv flights.tsv flights.tsv flights.tsv"
# cat ${moreFlights} ${moreFlights} ${moreFlights} ${moreFlights} > many_flights.tsv

time awk '{print $10, $1, $12}' many_flights.tsv > /dev/null
time kscript 'lines.split().select(10,1,12).print()' many_flights.tsv > /dev/null
```
For the tested case, `kscript` seems more than 30% faster than `awk`. Long live the JIT compiler! :-)


## Conceptual Clarity vs Convenience

One of the core motivations for the development of `kscript` is **long-term stability** of `kscript`lets. However, by adding a prefix header including a versioned dependency for the [kscript support API](https://github.com/holgerbrandl/kscript-support-api) we are somehow condemned to either stick to the current version of the support api for all times, or to hope that gradual improvements do not break existing kscript solutions. Neither option does sound appealing.

Because of that, we still consider to replace/drop the support for automatic prefixing of one-liners. The more verbose solution including the prefix-header would be fixed (and thus long-term stable) even if we evolve the support API, but for sure conciseness would suffer a  lot. See yourself:

```
kscript 'lines.split().select(with(1..3).and(3)).print()' file.txt
```
vs.

```
kscript '//DEPS de.mpicbg.scicomp:kscript:1.2
import kscript.text.*
val lines = resolveArgFile(args)

lines split().select(with(1..3).and(3)).print()
'
```
Readability would be better in the latter case because it is a self-contained Kotlin application.

Opinions and suggestions on this feature are welcome!


## Summary

As we have discussed above, `kscript` can be used as a drop-in replacement for awk in situations where `awk` solutions would become overly clumsy. By allowing for standard kotlin to write little pieces of shell processing logic, we can avoid installing external dedicated tools in many solutions. Although, `kscript`s written in `Kotlin` are slightly more verbose than `awk` code, they are more readable and allow to express more complex data flow logic.

Whereas as table streaming is certainly possible with `kscript` and beneficial in some situations, its true _true power_ is the handling of more complex data-types, such as  _json_, and _xml_, and domain specific data like _fasta_ or alignment files in bioinformatics. Because of the built-in dependency resolution in `kscript` third party libraries can be easily used in short concise mini-programs for a wide range of application domains. We plan to discuss examples in the next article.


{% include comments.html %}
